[{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/getting-started","content":"","keywords":""},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/getting-started#features","content":"‚úÖ Implements encoding and decoding via r50k_base, p50k_base, p50k_edit and cl100k_base ‚úÖ Easy-to-use API ‚úÖ Easy extensibility for custom encoding algorithms ‚úÖ Zero Dependencies ‚úÖ Supports Java 8 and above ‚úÖ Fast and efficient performance "},{"title":"Performance‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/getting-started#performance","content":"JTokkit reaches 2-3 times the throughput of a comparable tokenizer. Take a look in the benchmarks for more details. "},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction","url":"/docs/getting-started#installation","content":"You can install JTokkit by adding the following dependency to your Maven project: &lt;dependency&gt; &lt;groupId&gt;com.knuddels&lt;/groupId&gt; &lt;artifactId&gt;jtokkit&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt; &lt;/dependency&gt;  Or alternatively using Gradle: dependencies { implementation 'com.knuddels:jtokkit:0.6.1' }  "},{"title":"Counting Tokens for ChatML","type":0,"sectionRef":"#","url":"/docs/getting-started/recipes/chatml","content":"Counting Tokens for ChatML If you are using the OpenAI chat models, you need to account for additional tokens that are added to the input text. This recipe shows how to do that. It is based on this OpenAI Cookbook example. private int countMessageTokens( EncodingRegistry registry, String model, List&lt;ChatMessage&gt; messages // consists of role, content and an optional name ) { Encoding encoding = registry.getEncodingForModel(model).orElseThrow(); int tokensPerMessage; int tokensPerName if (model.startsWith(&quot;gpt-4&quot;)) { tokensPerMessage = 3; tokensPerName = 1; } else if (model.startsWith(&quot;gpt-3.5-turbo&quot;)) { tokensPerMessage = 4; // every message follows &lt;|start|&gt;{role/name}\\n{content}&lt;|end|&gt;\\n tokensPerName = -1; // if there's a name, the role is omitted } else { throw new IllegalArgumentException(&quot;Unsupported model: &quot; + model); } int sum = 0; for (final var message : messages) { sum += tokensPerMessage; sum += encoding.countTokens(message.getContent()); sum += encoding.countTokens(message.getRole()); if (message.hasName()) { sum += encoding.countTokens(message.getName()); sum += tokensPerName; } } sum += 3; // every reply is primed with &lt;|start|&gt;assistant&lt;|message|&gt; return sum; } ","keywords":""},{"title":"Extending JTokkit","type":0,"sectionRef":"#","url":"/docs/getting-started/extending","content":"","keywords":""},{"title":"Implementing the Encoding interface‚Äã","type":1,"pageTitle":"Extending JTokkit","url":"/docs/getting-started/extending#implementing-the-encoding-interface","content":"Implement the Encoding interface and register it with the EncodingRegistry. Make sure that the name you return from Encoding#getName is unique and that your implementation is thread-safe. It will be cached and reused by the EncodingRegistry. EncodingRegistry registry = Encodings.newDefaultEncodingRegistry(); Encoding customEncoding = new CustomEncoding(); registry.register(customEncoding); // Get the encoding from the registry Encoding encodingFromRegistry = registry.getEncoding(&quot;custom-name&quot;);  "},{"title":"Adding a new byte pair encoding‚Äã","type":1,"pageTitle":"Extending JTokkit","url":"/docs/getting-started/extending#adding-a-new-byte-pair-encoding","content":"You can add a new byte pair encoding by specifying the necessary parameters. EncodingRegistry registry = Encodings.newDefaultEncodingRegistry(); GptBytePairEncodingParams params = new GptBytePairEncodingParams( &quot;custom-name&quot;, Pattern.compile(&quot;some custom pattern&quot;), encodingMap, specialTokenEncodingMap ); registry.registerGptBytePairEncoding(params); // Get the encoding from the registry Encoding encodingFromRegistry = registry.getEncoding(&quot;custom-name&quot;);  Reference EncodingFactory for more details on the parameters and examples on how those parameters are used for the pre-defined encodings. "},{"title":"Usage","type":0,"sectionRef":"#","url":"/docs/getting-started/usage","content":"","keywords":""},{"title":"Getting an encoding from the registry‚Äã","type":1,"pageTitle":"Usage","url":"/docs/getting-started/usage#getting-an-encoding-from-the-registry","content":"You can use the registry to get the encodings you need: // Get encoding via type-safe enum Encoding encoding = registry.getEncoding(EncodingType.CL100K_BASE); // Get encoding via string name Optional&lt;Encoding&gt; encoding = registry.getEncoding(&quot;cl100k_base&quot;); // Get encoding for a specific model via type-safe enum Encoding encoding = registry.getEncodingForModel(ModelType.GPT_4); // Get encoding for a specific model via string name Optional&lt;Encoding&gt; encoding = registry.getEncodingForModel(&quot;gpt_4&quot;);  "},{"title":"Encoding and decoding text‚Äã","type":1,"pageTitle":"Usage","url":"/docs/getting-started/usage#encoding-and-decoding-text","content":"You can use an Encoding to encode and decode text: IntArrayList encoded = encoding.encode(&quot;This is a sample sentence.&quot;); // encoded = [2028, 374, 264, 6205, 11914, 13] String decoded = encoding.decode(encoded); // decoded = &quot;This is a sample sentence.&quot;  The encoding is also fully thread-safe and can be used concurrently by multiple components. info Note that the library currently does not support encoding of special tokens. Special tokens are artificial tokens used to unlock capabilities from a model, such as fill-in-the-middle. If the Encoding#encode method encounters a special token in the input text, it will throw an UnsupportedOperationException. If you want to encode special tokens as if they were normal text, you can use Encoding#encodeOrdinary instead: encoding.encode(&quot;hello &lt;|endoftext|&gt; world&quot;); // raises an UnsupportedOperationException encoding.encodeOrdinary(&quot;hello &lt;|endoftext|&gt; world&quot;); // returns [15339, 83739, 8862, 728, 428, 91, 29, 1917]  "},{"title":"Counting tokens‚Äã","type":1,"pageTitle":"Usage","url":"/docs/getting-started/usage#counting-tokens","content":"If all you want is the amount of tokens the text encodes to, you can use the shorthand method Encoding#countTokens or Encoding#countTokensOrdinary: int tokenCount = encoding.countTokens(&quot;This is a sample sentence.&quot;); // tokenCount = 6 int tokenCount = encoding.countTokensOrdinary(&quot;hello &lt;|endoftext|&gt; world&quot;); // tokenCount = 8  "},{"title":"Encoding text with truncation‚Äã","type":1,"pageTitle":"Usage","url":"/docs/getting-started/usage#encoding-text-with-truncation","content":"If you want to only encode up until a specified amount of maxTokens and truncate after that amount, you can use Encoding#encode(String, int) or Encoding#encodeOrdinary(String, int). These methods will truncate the encoded tokens to the specified length. They will automatically handle unicode characters that were split in half by the truncation by removing those tokens from the end of the list. IntArrayList encoded = encoding.encode(&quot;This is a sample sentence.&quot;, 3); // encoded = [2028, 374, 264] String decoded = encoding.decode(encoded); // decoded = &quot;This is a&quot; IntArrayList encoded = encoding.encode(&quot;I love üçï&quot;, 4); // encoded = [40, 3021] String decoded = encoding.decode(encoded); // decoded = &quot;I love&quot;  "}]